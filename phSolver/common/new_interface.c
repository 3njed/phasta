/* This file provides interface functions for 'partial ' random 
   access into the PHASTA input files 

   Anil Karanam March 2001 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
#include "mpi.h"
#include "phastaIO.h"
#include "common_c.h"
#include <FCMangle.h>

#ifdef intel
#include <winsock2.h>
#else
#include <unistd.h>
#include <strings.h>
#endif

#define Write_Restart FortranCInterface_GLOBAL_(write_restart,WRITE_RESTART)
#define Write_Error FortranCInterface_GLOBAL_(write_error,WRITE_ERROR)
#define Write_Displ FortranCInterface_GLOBAL_(write_displ,WRITE_DISPL)
#define Write_Field FortranCInterface_GLOBAL_(write_field,WRITE_FIELD)
#define Write_Field2 FortranCInterface_GLOBAL_(write_field2,WRITE_FIELD2)
#define Write_PhAvg FortranCInterface_GLOBAL_(write_phavg,WRITE_PHAVG)

extern char phasta_iotype[80];

void 
Write_Restart(  int* pid, 
                int* stepno, 
                int* nshg, 
                int* numVars,
                double* array1, 
                double* array2 ) {

    char fname[255];
    char rfile[60];
    char existingfile[30], linkfile[30];
    int irstou;
    int magic_number = 362436;
    int* mptr = &magic_number;
    time_t timenow = time ( &timenow);
    double version=0.0;
    int isize, nitems;
    int iarray[10];

    sprintf(rfile,"restart.%d.%d",*stepno,*pid+1);
    openfile(rfile,"write", &irstou);

    /* writing the top ascii header for the restart file */

    writestring( &irstou,"# PHASTA Input File Version 2.0\n");
    writestring( &irstou,
                  "# format \"keyphrase : sizeofnextblock usual headers\"\n");

    bzero( (void*)fname, 255 );
    sprintf(fname,"# Output generated by phasta version (NOT YET CURRENT): %lf \n", version);
    writestring( &irstou, fname );

    bzero( (void*)fname, 255 );
    gethostname(fname,255);
    writestring( &irstou,"# This result was produced on: ");
    writestring( &irstou, fname );
    writestring( &irstou,"\n");

    bzero( (void*)fname, 255 );
    sprintf(fname,"# %s\n", ctime( &timenow ));
    writestring( &irstou, fname );

    isize = 1;
    nitems = 1;
    iarray[ 0 ] = 1;
    writeheader( &irstou, "byteorder magic number ", 
                  (void*)iarray, &nitems, &isize, "integer", phasta_iotype );
    
    nitems = 1;
    writedatablock( &irstou, "byteorder magic number ",
                     (void*)mptr, &nitems, "integer", phasta_iotype );
    
    
    bzero( (void*)fname, 255 );
    sprintf(fname,"number of modes : < 0 > %d\n", *nshg);
    writestring( &irstou, fname );
    
    bzero( (void*)fname, 255 );
    sprintf(fname,"number of variables : < 0 > %d\n", *numVars);
    writestring( &irstou, fname );
        
    
    isize = (*nshg)*(*numVars);
    nitems = 3;
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numVars);
    iarray[ 2 ] = (*stepno);
    writeheader( &irstou, "solution ", 
                  (void*)iarray, &nitems, &isize, "double", phasta_iotype );
    
        
    nitems = (*nshg)*(*numVars);
    writedatablock( &irstou, "solution ",
                     (void*)(array1), &nitems, "double", phasta_iotype );
        
   

    nitems = 3;
    writeheader( &irstou, "time derivative of solution ", 
                  (void*)iarray, &nitems, &isize, "double", phasta_iotype );
    
    
    nitems = (*nshg)*(*numVars);
    writedatablock( &irstou, "time derivative of solution ",
                     (void*)(array2), &nitems, "double", phasta_iotype );

        
    closefile( &irstou, "write" );
      
    MPI_Barrier(MPI_COMM_WORLD);

    /* create a soft link of the restart we just wrote to restart.latest
     this is the file the next run will always try to start from */

    /* sprintf( linkfile, "restart.latest.%d", *pid+1 );
    unlink( linkfile );
    sprintf( existingfile, "restart.%d.%d", *stepno, *pid+1 );
    link( existingfile, linkfile ); */
}

void 
Write_Error(  int* pid, 
              int* stepno, 
              int* nshg, 
              int* numVars,
              double* array1 ) { 


    char fname[255];
    char rfile[60];
    int irstou;
    int magic_number = 362436;
    int* mptr = &magic_number;
    time_t timenow = time ( &timenow);
    double version=0.0;
    int isize, nitems;
    int iarray[10];

    sprintf(rfile,"restart.%d.%d",*stepno,*pid+1);
    openfile(rfile,"append", &irstou);

    isize = (*nshg)*(*numVars);
    nitems = 3;
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numVars);
    iarray[ 2 ] = (*stepno);
    writeheader( &irstou, "errors", (void*)iarray, &nitems, &isize, "double", phasta_iotype );
    
        
    nitems = (*nshg)*(*numVars);
    writedatablock( &irstou, "errors ", (void*)(array1), &nitems, "double", phasta_iotype );

    closefile( &irstou, "append" );
    
}


void 
Write_Displ(  int* pid, 
              int* stepno, 
              int* nshg, 
              int* numVars,
              double* array1 ) { 


    char fname[255];
    char rfile[60];
    int irstou;
    int magic_number = 362436;
    int* mptr = &magic_number;
    time_t timenow = time ( &timenow);
    double version=0.0;
    int isize, nitems;
    int iarray[10];

    sprintf(rfile,"restart.%d.%d",*stepno,*pid+1);
    openfile(rfile,"append", &irstou);

    isize = (*nshg)*(*numVars);
    nitems = 3;
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numVars);
    iarray[ 2 ] = (*stepno);
    writeheader( &irstou, "displacement", (void*)iarray, &nitems, &isize, "double", phasta_iotype );
    
        
    nitems = (*nshg)*(*numVars);
    writedatablock( &irstou, "displacement", (void*)(array1), &nitems, "double", phasta_iotype );

    closefile( &irstou, "append" );
    
}

void 
Write_Field(  int *pid,
              char* filemode,
	      char* fieldtag,
              int* tagsize,
	      void* array,
              char* arraytype,
	      int* nshg,
	      int* numvars,
	      int* stepno) {

    char rfile[32];
    // assuming restart.sn.(pid+1)
    sprintf(rfile,"restart.%d.%d",*stepno,*pid+1);

    char *fieldlabel = (char *)malloc((*tagsize+1)*sizeof(char));
    strncpy(fieldlabel, fieldtag, *tagsize);
    fieldlabel[*tagsize] = '\0';

    int irstou;
    int magic_number = 362436;
    int* mptr = &magic_number;
    double version=0.0;
    int isize, nitems;
    int iarray[10];

    char fmode[10];
    if(!strncmp(filemode,"w",1))
      strcpy(fmode,"write");
    else // default is append
      strcpy(fmode,"append");

    char datatype[10];
    if(!strncmp(arraytype,"i",1))
      strcpy(datatype,"int");
    else // default is double
      strcpy(datatype,"double");

    openfile(rfile, fmode, &irstou);

    nitems = 3; // assuming field will write 4 items in iarray
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numvars);
    iarray[ 2 ] = (*stepno);

    isize = (*nshg)*(*numvars);
    writeheader( &irstou, fieldlabel, (void*)iarray, &nitems, &isize, datatype, phasta_iotype );

    nitems = (*nshg)*(*numvars);
    writedatablock( &irstou, fieldlabel, array, &nitems, datatype, phasta_iotype );

    closefile( &irstou, fmode);

    free(fieldlabel); 
}

// this function writes only ybar data into ybar file of current time step
void
Write_Field2(  int *pid,    //process ID
              char* filemode, // write or append, default is append
              char* fieldtag, // ybar,error,... VERY IMPORTANT: solution field is handled by Write_Restart
              int* tagsize,   // number of letters of the tag name, for ybar it is 4
              void* array,    // the data array to be writted
              char* arraytype,  // the data type of the data array, normally it is double
              int* nshg,      // number of turples, can be total number of points (nshg) or total number of cells
              int* numvars,   // number of variables, for ybar it is 13 (excluding SA turbulence model variable nu_tilda ) 
              int* stepno,    //  current time step number, starting from numstart.dat, inheritad from last job
              int* stepruns) { // istep, total time steps since this job

    char rfile[32];
    // assuming restart.sn.(pid+1)
    sprintf(rfile,"ybar.%d-%d.%d",*stepno-*stepruns,*stepno,*pid+1);
    char *fieldlabel = (char *)malloc((*tagsize+1)*sizeof(char));
    strncpy(fieldlabel, fieldtag, *tagsize);
    fieldlabel[*tagsize] = '\0';
    int irstou;
    int magic_number = 362436;
    int* mptr = &magic_number;
    double version=0.0;
    int isize, nitems;
    int iarray[10];
    char fmode[10];
    if(!strncmp(filemode,"w",1))
      strcpy(fmode,"write");
    else // default is append, very important information
      strcpy(fmode,"append");
    char datatype[10];
    if(!strncmp(arraytype,"i",1))
      strcpy(datatype,"int");
    else // default is double
      strcpy(datatype,"double");
    openfile(rfile, fmode, &irstou);
    nitems = 4; // assuming field will write 4 items in iarray
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numvars);
    iarray[ 2 ] = (*stepno);
    iarray[ 3 ] = (*stepruns);
    isize = (*nshg)*(*numvars);
    writeheader( &irstou, fieldlabel, (void*)iarray, &nitems, &isize, datatype, phasta_iotype );
    nitems = (*nshg)*(*numvars);
    writedatablock( &irstou, fieldlabel, array, &nitems, datatype, phasta_iotype );
    closefile( &irstou, fmode);
    free(fieldlabel);
}


void 
Write_PhAvg(  int *pid,
              char* filemode,
              char* fieldtag,
              int* tagsize,
              int* iphase,
	      void* array,
              char* arraytype,
	      int* nshg,
	      int* numvars,
	      int* stepno) {

    char rfile[32];
    // assuming restart_phase_avg_<sn>.<iphase>.<pid+1>
    sprintf(rfile,"restart_phase_avg_%d.%d.%d",*stepno,*iphase,*pid+1);

    char *fieldlabel = (char *)malloc((*tagsize+1)*sizeof(char));
    strncpy(fieldlabel, fieldtag, *tagsize);
    fieldlabel[*tagsize] = '\0';

    int irstou;
    int isize, nitems;
    int iarray[10];

    char fmode[10];
    if(!strncmp(filemode,"w",1))
      strcpy(fmode,"write");
    else // default is append
      strcpy(fmode,"append");

    char datatype[10];
    if(!strncmp(arraytype,"i",1))
      strcpy(datatype,"int");
    else // default is double
      strcpy(datatype,"double");

    openfile(rfile, fmode, &irstou);

    if(!strcmp(fmode,"write")) {
      // may be create a routine for 'top' portion under write mode
      int magic_number = 362436;
      int* mptr = &magic_number;
      time_t timenow = time ( &timenow);
      double version=0.0;

      /* writing the top ascii header for the restart file */

      writestring( &irstou,"# PHASTA Input File Version 2.0\n");
      writestring( &irstou,
                    "# format \"keyphrase : sizeofnextblock usual headers\"\n");

      char fname[255];
      bzero( (void*)fname, 255 );
      sprintf(fname,"# Output generated by phasta version (NOT YET CURRENT): %lf \n", version);
      writestring( &irstou, fname );

      bzero( (void*)fname, 255 );
      gethostname(fname,255);
      writestring( &irstou,"# This result was produced on: ");
      writestring( &irstou, fname );
      writestring( &irstou,"\n");

      bzero( (void*)fname, 255 );
      sprintf(fname,"# %s\n", ctime( &timenow ));
      writestring( &irstou, fname );

      isize = 1;
      nitems = 1;
      iarray[ 0 ] = 1;
      writeheader( &irstou, "byteorder magic number ", 
                    (void*)iarray, &nitems, &isize, "integer", phasta_iotype );
    
      nitems = 1;
      writedatablock( &irstou, "byteorder magic number ",
                       (void*)mptr, &nitems, "integer", phasta_iotype );
    }
    
    nitems = 3; // assuming field will write 3 items in iarray
    iarray[ 0 ] = (*nshg);
    iarray[ 1 ] = (*numvars);
    iarray[ 2 ] = (*stepno);

    isize = (*nshg)*(*numvars);
    writeheader( &irstou, fieldlabel, (void*)iarray, &nitems, &isize, datatype, phasta_iotype );

    nitems = (*nshg)*(*numvars);
    writedatablock( &irstou, fieldlabel, array, &nitems, datatype, phasta_iotype );

    closefile( &irstou, fmode);

    free(fieldlabel); 
}
